name: Multi-Service Deployment Pipeline

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  workflow_dispatch:
    inputs:
      deploy_to_aws:
        description: 'Deploy to AWS EC2'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      force_rebuild:
        description: 'Force rebuild all Docker images'
        required: false
        default: false
        type: boolean

env:
  JAVA_VERSION: '17'
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.9'
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  # Test UPS Services
  ups-test:
    name: Test UPS Services
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: abc123
          POSTGRES_USER: postgres
          POSTGRES_DB: ups_db_test
        options: >-
          --health-cmd "pg_isready -U postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          
      - name: Verify Java version
        run: |
          echo "ğŸ” Verifying Java setup..."
          echo "JAVA_HOME: $JAVA_HOME"
          java -version
          javac -version
          mvn -version | grep -E "(Java version|JVM)"
          echo "âœ… Java ${{ env.JAVA_VERSION }} verified"

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('backend/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Cache npm dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('frontend/package-lock.json') }}
          restore-keys: ${{ runner.os }}-node-

      - name: Install PostgreSQL and Redis clients
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client redis-tools

      - name: Verify test environment
        run: |
          echo "ğŸ” Verifying test environment setup..."
          echo "PostgreSQL service status:"
          docker ps --filter "ancestor=postgres:15" --format "table {{.ID}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
          echo "Redis service status:"
          docker ps --filter "ancestor=redis:7-alpine" --format "table {{.ID}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
          
          echo "Testing database connectivity..."
          pg_isready -h localhost -p 5432 -U postgres || { echo "âŒ PostgreSQL not ready"; exit 1; }
          echo "âœ… PostgreSQL is ready"
          
          echo "Testing Redis connectivity..."
          redis-cli -h localhost -p 6379 ping || { echo "âŒ Redis not ready"; exit 1; }
          echo "âœ… Redis is ready"
          
          echo "âœ… Test environment verified"

      - name: Test backend
        working-directory: ./backend
        run: |
          echo "ğŸ§ª Testing UPS Backend..."
          mvn clean test -Dspring.profiles.active=test -DfailIfNoTests=false
        env:
          # Force H2 database for unit tests to avoid PostgreSQL connection issues
          SPRING_DATASOURCE_URL: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
          SPRING_DATASOURCE_DRIVER_CLASS_NAME: org.h2.Driver
          SPRING_DATASOURCE_USERNAME: sa
          SPRING_DATASOURCE_PASSWORD: ""
          # Redis configuration for integration tests that need it
          TEST_REDIS_HOST: localhost
          TEST_REDIS_PORT: 6379
          # JVM options
          MAVEN_OPTS: "-Xmx1024m -XX:+UseG1GC --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED"

      - name: Test and build frontend
        working-directory: ./frontend
        run: |
          echo "ğŸ§ª Testing UPS Frontend..."
          npm ci --legacy-peer-deps --prefer-offline --no-audit
          npm run type-check:ci
          npm run test
          npm run build:ci
        env:
          CI: true
          VITE_API_BASE_URL: http://localhost:8081
          VITE_APP_VERSION: ${{ github.sha }}

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ups-test-results
          path: |
            backend/target/surefire-reports/
            frontend/coverage/
          retention-days: 7

  # Validate Amazon and World Simulator Services
  # external-services-validate:
  #   name: Validate External Services
  #   runs-on: ubuntu-latest
  #   
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Set up Python ${{ env.PYTHON_VERSION }}
  #       uses: actions/setup-python@v4
  #       with:
  #         python-version: ${{ env.PYTHON_VERSION }}

  #     # - name: Validate Amazon service structure
  #     #   run: |
  #     #     echo "ğŸ” Validating Amazon service..."
  #     #     ls -la knowledge/amazon/
  #     #     test -f knowledge/amazon/Dockerfile
  #     #     test -f knowledge/amazon/requirements.txt
  #     #     test -f knowledge/amazon/app/__init__.py
  #     #     echo "âœ… Amazon service structure validated"

  #     - name: Validate World Simulator structure
  #       run: |
  #         echo "ğŸ” Validating World Simulator..."
  #         ls -la knowledge/world_simulator_exec/docker_deploy/
  #         test -f knowledge/world_simulator_exec/docker_deploy/Dockerfile
  #         test -f knowledge/world_simulator_exec/docker_deploy/docker-compose.yml
  #         test -f knowledge/world_simulator_exec/docker_deploy/server
  #         echo "âœ… World Simulator structure validated"

  #     # - name: Test Amazon service dependencies
  #     #   working-directory: ./knowledge/amazon
  #     #   run: |
  #     #     echo "ğŸ” Testing Amazon dependencies..."
  #     #     pip install -r requirements.txt
  #     #     python -c "import flask; print('Flask version:', flask.__version__)"
  #     #     python -c "import psycopg2; print('PostgreSQL driver ready')"
  #     #     echo "âœ… Amazon dependencies validated"

  # Build Docker Images
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [ups-test]
    if: success()
    
    outputs:
      ups-backend-tag: ${{ steps.meta.outputs.ups-backend-tag }}
      ups-frontend-tag: ${{ steps.meta.outputs.ups-frontend-tag }}
      amazon-tag: ${{ steps.meta.outputs.amazon-tag }}
      world-sim-tag: ${{ steps.meta.outputs.world-sim-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub (optional)
        if: github.ref == 'refs/heads/main' && github.event.inputs.deploy_to_aws == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Generate image metadata
        id: meta
        run: |
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          SHORT_SHA=${GITHUB_SHA:0:8}
          
          echo "ups-backend-tag=mini-ups-backend:${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "ups-frontend-tag=mini-ups-frontend:${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "amazon-tag=mini-amazon:${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "world-sim-tag=mini-world-sim:${SHORT_SHA}" >> $GITHUB_OUTPUT

      - name: Build UPS Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: false
          load: true
          tags: ${{ steps.meta.outputs.ups-backend-tag }}
          cache-from: type=gha,scope=ups-backend
          cache-to: type=gha,mode=max,scope=ups-backend

      - name: Build UPS Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          target: production
          push: false
          load: true
          tags: ${{ steps.meta.outputs.ups-frontend-tag }}
          cache-from: type=gha,scope=ups-frontend
          cache-to: type=gha,mode=max,scope=ups-frontend

      # - name: Build Amazon Service
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: ./knowledge/amazon
      #     file: ./knowledge/amazon/Dockerfile
      #     push: false
      #     tags: ${{ steps.meta.outputs.amazon-tag }}
      #     cache-from: type=gha,scope=amazon
      #     cache-to: type=gha,mode=max,scope=amazon

      # - name: Build World Simulator
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: ./knowledge/world_simulator_exec/docker_deploy
      #     file: ./knowledge/world_simulator_exec/docker_deploy/Dockerfile
      #     push: false
      #     tags: ${{ steps.meta.outputs.world-sim-tag }}
      #     cache-from: type=gha,scope=world-sim
      #     cache-to: type=gha,mode=max,scope=world-sim

      - name: Save Docker images as artifacts
        run: |
          echo "ğŸ’¾ Saving Docker images..."
          echo "Available Docker images:"
          docker images
          
          echo "Saving UPS Backend image..."
          if docker image inspect ${{ steps.meta.outputs.ups-backend-tag }} >/dev/null 2>&1; then
            docker save ${{ steps.meta.outputs.ups-backend-tag }} | gzip > ups-backend.tar.gz
            echo "âœ… UPS Backend image saved: $(du -h ups-backend.tar.gz)"
          else
            echo "âŒ UPS Backend image not found: ${{ steps.meta.outputs.ups-backend-tag }}"
            exit 1
          fi
          
          echo "Saving UPS Frontend image..."
          if docker image inspect ${{ steps.meta.outputs.ups-frontend-tag }} >/dev/null 2>&1; then
            docker save ${{ steps.meta.outputs.ups-frontend-tag }} | gzip > ups-frontend.tar.gz
            echo "âœ… UPS Frontend image saved: $(du -h ups-frontend.tar.gz)"
          else
            echo "âŒ UPS Frontend image not found: ${{ steps.meta.outputs.ups-frontend-tag }}"
            exit 1
          fi
          
          # docker save ${{ steps.meta.outputs.amazon-tag }} | gzip > amazon.tar.gz
          # docker save ${{ steps.meta.outputs.world-sim-tag }} | gzip > world-sim.tar.gz
          
          echo "Final saved images:"
          ls -lh *.tar.gz

      - name: Upload Docker images
        uses: actions/upload-artifact@v4
        with:
          name: docker-images
          path: |
            ups-backend.tar.gz
            ups-frontend.tar.gz
            # amazon.tar.gz
            # world-sim.tar.gz
          retention-days: 1

  # Integration Test
  integration-test:
    name: Integration Test
    runs-on: ubuntu-latest
    needs: [build-images]
    if: success()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker images
        uses: actions/download-artifact@v4
        with:
          name: docker-images

      - name: Load Docker images
        run: |
          echo "ğŸ“¦ Loading Docker images..."
          ls -la *.tar.gz || echo "No image files found"
          if [ -f "ups-backend.tar.gz" ]; then
            docker load < ups-backend.tar.gz
          else
            echo "ups-backend.tar.gz not found, skipping..."
          fi
          if [ -f "ups-frontend.tar.gz" ]; then
            docker load < ups-frontend.tar.gz
          else
            echo "ups-frontend.tar.gz not found, skipping..."
          fi
          # docker load < amazon.tar.gz
          # docker load < world-sim.tar.gz
          docker images

      - name: Create test environment and compose files
        run: |
          echo "ğŸ”§ Creating test environment file..."
          
          # Check if .env.production exists, fallback to .env.ci or create basic one
          if [ -f ".env.production" ]; then
            echo "Using .env.production as base"
            cp .env.production .env.test
          elif [ -f ".env.ci" ]; then
            echo "Using .env.ci as base"
            cp .env.ci .env.test
          else
            echo "Creating basic .env.test file"
            cat > .env.test << EOF
          # Test Environment Configuration
          SPRING_PROFILES_ACTIVE=test
          
          # Database Configuration
          POSTGRES_HOST=mini-ups-postgres
          POSTGRES_PORT=5432
          POSTGRES_DB=ups_db
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=abc123
          
          # Redis Configuration
          REDIS_HOST=mini-ups-redis
          REDIS_PORT=6379
          
          # JWT Configuration
          JWT_SECRET=test-secret-key-for-integration-tests-only
          
          # External Services
          WORLD_HOST=host.docker.internal
          WORLD_PORT=12345
          AMAZON_API_URL=http://host.docker.internal:8080
          EOF
          fi
          
          # Override with our built image tags
          echo "" >> .env.test  # Add a newline first
          echo "# Updated image tags from CI build" >> .env.test
          echo "UPS_BACKEND_IMAGE=${{ needs.build-images.outputs.ups-backend-tag }}" >> .env.test
          echo "UPS_FRONTEND_IMAGE=${{ needs.build-images.outputs.ups-frontend-tag }}" >> .env.test
          
          echo "âœ… Test environment file created:"
          echo "--- .env.test content ---"
          cat .env.test
          echo "------------------------"
          
          # Create a test-specific docker-compose file with only UPS services
          echo "ğŸ”§ Creating test docker-compose file..."
          cat > docker-compose.test.yml << 'EOF'
          services:
            # ===== UPS Services Only =====
            # PostgreSQLæ•°æ®åº“ (UPS)
            ups-database:
              image: postgres:15
              container_name: mini-ups-postgres-test
              environment:
                POSTGRES_DB: ups_db
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: abc123
                TZ: UTC
              ports:
                - "5431:5432"
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5
              restart: unless-stopped
              networks:
                - mini-ups-network
          
            # Redisç¼“å­˜ (UPS)
            ups-redis:
              image: redis:7-alpine
              container_name: mini-ups-redis-test
              command: redis-server --requirepass test123
              ports:
                - "6380:6379"
              healthcheck:
                test: ["CMD", "redis-cli", "-a", "test123", "ping"]
                interval: 10s
                timeout: 5s
                retries: 5
              restart: unless-stopped
              networks:
                - mini-ups-network
          
            # RabbitMQæ¶ˆæ¯é˜Ÿåˆ— (UPS)
            ups-rabbitmq:
              image: rabbitmq:3.13-management-alpine
              container_name: mini-ups-rabbitmq-test
              environment:
                RABBITMQ_DEFAULT_USER: guest
                RABBITMQ_DEFAULT_PASS: guest
              ports:
                - "5672:5672"
                - "15672:15672"
              healthcheck:
                test: ["CMD", "rabbitmq-diagnostics", "-q", "ping"]
                interval: 15s
                timeout: 10s
                retries: 5
              restart: unless-stopped
              networks:
                - mini-ups-network
          
            # Spring Bootåç«¯ (UPS)
            ups-backend:
              image: ${UPS_BACKEND_IMAGE}
              container_name: mini-ups-backend-test
              pull_policy: never
              environment:
                SPRING_PROFILES_ACTIVE: docker
                # Database connection - using both formats for compatibility
                DATABASE_URL: jdbc:postgresql://ups-database:5432/ups_db
                DATABASE_USERNAME: postgres
                DATABASE_PASSWORD: abc123
                DATABASE_DIALECT: org.hibernate.dialect.PostgreSQLDialect
                # Legacy format variables as fallback
                POSTGRES_HOST: ups-database
                POSTGRES_PORT: 5432
                POSTGRES_DB: ups_db
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: abc123
                # Redis configuration
                REDIS_HOST: ups-redis
                REDIS_PORT: 6379
                REDIS_PASSWORD: test123
                # RabbitMQ configuration
                SPRING_RABBITMQ_HOST: ups-rabbitmq
                SPRING_RABBITMQ_PORT: 5672
                SPRING_RABBITMQ_USERNAME: guest
                SPRING_RABBITMQ_PASSWORD: guest
                # JWT configuration
                JWT_SECRET: test_jwt_secret_for_integration_tests
                # Mock external services for testing
                WORLD_SIMULATOR_HOST: localhost
                WORLD_SIMULATOR_PORT: 12345
                AMAZON_API_URL: http://localhost:8080
                NUM_TRUCKS: 3
              ports:
                - "8081:8081"
              depends_on:
                ups-database:
                  condition: service_healthy
                ups-redis:
                  condition: service_healthy
                ups-rabbitmq:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8081/actuator/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
              restart: unless-stopped
              networks:
                - mini-ups-network
          
            # Reactå‰ç«¯ (UPS)
            ups-frontend:
              image: ${UPS_FRONTEND_IMAGE}
              container_name: mini-ups-frontend-test
              pull_policy: never
              environment:
                BACKEND_HOST: ups-backend
                BACKEND_PORT: 8081
              ports:
                - "3000:8080"
              depends_on:
                - ups-backend
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 30s
              restart: unless-stopped
              networks:
                - mini-ups-network
          
          networks:
            mini-ups-network:
              name: mini-ups-test-network
              driver: bridge
          EOF
          
          echo "âœ… Test docker-compose file created"

      - name: Start multi-service stack
        run: |
          echo "ğŸš€ Starting UPS services for integration testing..."
          
          # Verify environment variables are set correctly
          echo "ğŸ” Verifying environment variables..."
          echo "Contents of .env.test file:"
          cat .env.test
          echo "------------------------"
          
          # Get the last occurrence of each variable (should be the ones we added)
          # Also handle cases where the line might be concatenated
          UPS_BACKEND_IMAGE=$(grep -o "UPS_BACKEND_IMAGE=[^[:space:]]*" .env.test | tail -1 | cut -d'=' -f2)
          UPS_FRONTEND_IMAGE=$(grep -o "UPS_FRONTEND_IMAGE=[^[:space:]]*" .env.test | tail -1 | cut -d'=' -f2)
          echo "Extracted UPS_BACKEND_IMAGE=${UPS_BACKEND_IMAGE}"
          echo "Extracted UPS_FRONTEND_IMAGE=${UPS_FRONTEND_IMAGE}"
          
          # Show all available images
          echo "Available Docker images:"
          docker images | grep -E "(mini-ups|REPOSITORY)"
          
          # Verify the images exist locally
          echo "ğŸ” Verifying local images exist..."
          docker image inspect ${UPS_BACKEND_IMAGE} || { echo "âŒ Backend image not found"; exit 1; }
          docker image inspect ${UPS_FRONTEND_IMAGE} || { echo "âŒ Frontend image not found"; exit 1; }
          
          # Start services
          echo "ğŸš€ Starting Docker Compose services..."
          docker compose -f docker-compose.test.yml --env-file .env.test up -d
          
          # Wait for services to be ready with better health checking
          echo "â³ Waiting for services to start..."
          
          # Wait for database to be ready first
          echo "ğŸ” Waiting for database to be ready..."
          for i in {1..30}; do
            if docker exec mini-ups-postgres-test pg_isready -U postgres >/dev/null 2>&1; then
              echo "âœ… Database is ready!"
              break
            fi
            echo "â³ Database not ready yet... (attempt $i/30)"
            sleep 2
          done
          
          # Wait for Redis to be ready
          echo "ğŸ” Waiting for Redis to be ready..."
          for i in {1..15}; do
            if docker exec mini-ups-redis-test redis-cli -a test123 ping >/dev/null 2>&1; then
              echo "âœ… Redis is ready!"
              break
            fi
            echo "â³ Redis not ready yet... (attempt $i/15)"
            sleep 2
          done
          
          # Wait for RabbitMQ to be ready
          echo "ğŸ” Waiting for RabbitMQ to be ready..."
          for i in {1..20}; do
            if docker exec mini-ups-rabbitmq-test rabbitmq-diagnostics -q ping >/dev/null 2>&1; then
              echo "âœ… RabbitMQ is ready!"
              break
            fi
            echo "â³ RabbitMQ not ready yet... (attempt $i/20)"
            sleep 3
          done
          
          # Wait for backend to be ready with extended timeout
          echo "ğŸ” Waiting for UPS Backend to be ready..."
          for i in {1..60}; do
            if curl -f http://localhost:8081/actuator/health >/dev/null 2>&1; then
              echo "âœ… UPS Backend is ready!"
              break
            fi
            echo "â³ UPS Backend not ready yet... (attempt $i/60)"
            sleep 5
          done
          
          # Show service status
          echo "ğŸ“Š Service status:"
          docker compose -f docker-compose.test.yml --env-file .env.test ps

      - name: Run integration tests
        run: |
          echo "ğŸ§ª Running UPS integration tests..."
          
          # Show current service status first
          echo "ğŸ“Š Current service status:"
          docker compose -f docker-compose.test.yml --env-file .env.test ps
          
          # Health checks for UPS services only
          echo "ğŸ” Testing UPS Backend health..."
          if curl -f http://localhost:8081/actuator/health; then
            echo "âœ… UPS Backend health check passed"
          else
            echo "âŒ UPS Backend health check failed"
            echo "ğŸ“‹ Backend logs:"
            docker logs mini-ups-backend-test --tail=50
            exit 1
          fi
          
          echo "ğŸ” Testing UPS Frontend..."
          if curl -f http://localhost:3000; then
            echo "âœ… UPS Frontend is accessible"
          else
            echo "âŒ UPS Frontend is not accessible"
            echo "ğŸ“‹ Frontend logs:"
            docker logs mini-ups-frontend-test --tail=20
            exit 1
          fi
          
          # Database connectivity
          echo "ğŸ” Testing UPS database connection..."
          if docker exec mini-ups-postgres-test pg_isready -U postgres; then
            echo "âœ… Database connection successful"
          else
            echo "âŒ Database connection failed"
            exit 1
          fi
          
          # Redis connectivity
          echo "ğŸ” Testing UPS Redis connection..."
          if docker exec mini-ups-redis-test redis-cli -a test123 ping; then
            echo "âœ… Redis connection successful"
          else
            echo "âŒ Redis connection failed"
            exit 1
          fi
          
          # RabbitMQ connectivity
          echo "ğŸ” Testing UPS RabbitMQ connection..."
          if docker exec mini-ups-rabbitmq-test rabbitmq-diagnostics -q ping; then
            echo "âœ… RabbitMQ connection successful"
          else
            echo "âŒ RabbitMQ connection failed"
            exit 1
          fi
          
          # Basic API test
          echo "ğŸ” Testing UPS API endpoints..."
          curl -f http://localhost:8081/api/health && echo "âœ… API health endpoint available" || echo "â„¹ï¸ API health endpoint not available (may be expected)"
          
          echo ""
          echo "ğŸ‰ All UPS integration tests passed!"
          echo "âœ… Backend: Healthy"
          echo "âœ… Frontend: Accessible" 
          echo "âœ… Database: Connected"
          echo "âœ… Redis: Connected"

      - name: Check service logs
        if: failure()
        run: |
          echo "ğŸ“‹ UPS Service logs for troubleshooting..."
          docker compose -f docker-compose.test.yml --env-file .env.test logs --tail=50

      - name: Cleanup test environment
        if: always()
        run: |
          echo "ğŸ§¹ Cleaning up test environment..."
          docker compose -f docker-compose.test.yml --env-file .env.test down -v
          docker system prune -f

  # Deploy to AWS EC2
  deploy-aws:
    name: Deploy to AWS EC2
    runs-on: ubuntu-latest
    needs: [integration-test, build-images]
    if: |
      github.ref == 'refs/heads/main' && 
      (github.event.inputs.deploy_to_aws == 'true' || github.event_name == 'push')
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker images
        uses: actions/download-artifact@v4
        with:
          name: docker-images

      - name: Copy Docker images to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "*.tar.gz"
          target: "/home/ubuntu/mini-ups/images/"

      - name: Copy deployment files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "docker-compose.production.yml,.env.production,scripts/"
          target: "/home/ubuntu/mini-ups/"

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          timeout: 600s
          script: |
            set -e
            
            echo "ğŸš€ Starting deployment to AWS EC2..."
            
            # Navigate to application directory
            cd /home/ubuntu/mini-ups || { 
              echo "Creating application directory..."
              mkdir -p /home/ubuntu/mini-ups
              cd /home/ubuntu/mini-ups
            }
            
            # Load Docker images first
            echo "ğŸ“¦ Loading Docker images..."
            cd images/
            for image in *.tar.gz; do
              if [ -f "$image" ]; then
                echo "Loading $image..."
                docker load < "$image"
              fi
            done
            rm -f *.tar.gz
            cd ..
            
            # Clone/update repository with full codebase
            if [ -d ".git" ]; then
              echo "ğŸ“¥ Updating code..."
              git pull origin main
            else
              echo "ğŸ“¥ Cloning repository..."
              git clone https://github.com/${{ github.repository }}.git .
            fi
            
            # Stop existing services
            echo "â¹ï¸  Stopping existing services..."
            docker compose -f docker-compose.production.yml down || true
            
            # Clean up old containers and volumes if needed
            echo "ğŸ§¹ Cleaning up old resources..."
            docker system prune -f || true
            
            # Create production environment
            echo "âš™ï¸  Setting up production environment..."
            cp .env.production .env.production.deploy
            echo "" >> .env.production.deploy
            echo "# CI/CD Updated Values" >> .env.production.deploy
            echo "UPS_BACKEND_IMAGE=${{ needs.build-images.outputs.ups-backend-tag }}" >> .env.production.deploy
            echo "UPS_FRONTEND_IMAGE=${{ needs.build-images.outputs.ups-frontend-tag }}" >> .env.production.deploy
            echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env.production.deploy
            echo "AMAZON_SECRET_KEY=${{ secrets.AMAZON_SECRET_KEY }}" >> .env.production.deploy
            
            # Create necessary directories
            echo "ğŸ“ Creating directories..."
            sudo mkdir -p /var/log/mini-ups /var/backups/mini-ups
            sudo chown -R ubuntu:ubuntu /var/log/mini-ups /var/backups/mini-ups
            mkdir -p logs data backup
            
            # Make scripts executable
            chmod +x scripts/*.sh || true
            
            # Build any missing Docker images for external services
            echo "ğŸ”¨ Building external service images if needed..."
            
            # Build Amazon service
            if [ -d "knowledge/amazon" ]; then
              echo "Building Amazon service..."
              docker build -t mini-amazon:latest knowledge/amazon/ || echo "Warning: Amazon build failed"
            fi
            
            # Build World Simulator
            if [ -d "knowledge/world_simulator_exec/docker_deploy" ]; then
              echo "Building World Simulator..."
              docker build -t mini-world-sim:latest knowledge/world_simulator_exec/docker_deploy/ || echo "Warning: World Simulator build failed"
            fi
            
            # Start services with better orchestration
            echo "ğŸ”„ Starting services..."
            docker compose -f docker-compose.production.yml --env-file .env.production.deploy up -d --remove-orphans
            
            # Wait for core infrastructure first
            echo "â³ Waiting for core infrastructure..."
            sleep 60
            
            # Check databases one by one
            echo "ğŸ” Checking databases..."
            for i in {1..30}; do
              if docker exec mini-ups-postgres pg_isready -U postgres >/dev/null 2>&1; then
                echo "âœ… UPS Database is ready!"
                break
              fi
              echo "â³ Waiting for UPS Database... (Attempt $i/30)"
              sleep 5
            done
            
            for i in {1..30}; do
              if docker exec mini-amazon-db pg_isready -U postgres >/dev/null 2>&1; then
                echo "âœ… Amazon Database is ready!"
                break
              fi
              echo "â³ Waiting for Amazon Database... (Attempt $i/30)"
              sleep 5
            done
            
            for i in {1..30}; do
              if docker exec world-simulator-db pg_isready -U postgres >/dev/null 2>&1; then
                echo "âœ… World Simulator Database is ready!"
                break
              fi
              echo "â³ Waiting for World Simulator Database... (Attempt $i/30)"
              sleep 5
            done
            
            # Check Redis
            echo "ğŸ” Checking Redis..."
            for i in {1..20}; do
              if docker exec mini-ups-redis redis-cli ping >/dev/null 2>&1; then
                echo "âœ… Redis is ready!"
                break
              fi
              echo "â³ Waiting for Redis... (Attempt $i/20)"
              sleep 3
            done
            
            # Wait for applications
            echo "â³ Waiting for applications to start..."
            sleep 90
            
            # Health checks with better error handling
            echo "ğŸ” Running comprehensive health checks..."
            
            # Check UPS Backend
            echo "Testing UPS Backend..."
            for i in {1..30}; do
              if curl -f -s http://localhost:8081/actuator/health >/dev/null 2>&1; then
                echo "âœ… UPS Backend is healthy!"
                break
              fi
              echo "â³ Waiting for UPS Backend... (Attempt $i/30)"
              sleep 10
            done
            
            # Check UPS Frontend
            echo "Testing UPS Frontend..."
            for i in {1..15}; do
              if curl -f -s http://localhost:3000 >/dev/null 2>&1; then
                echo "âœ… UPS Frontend is healthy!"
                break
              fi
              echo "â³ Waiting for UPS Frontend... (Attempt $i/15)"
              sleep 5
            done
            
            # Check Amazon Service
            echo "Testing Amazon Service..."
            for i in {1..20}; do
              if curl -f -s http://localhost:8080 >/dev/null 2>&1; then
                echo "âœ… Amazon service is healthy!"
                break
              fi
              echo "â³ Waiting for Amazon service... (Attempt $i/20)"
              sleep 8
            done
            
            # Final status check
            echo "ğŸ“Š Final service status:"
            docker compose -f docker-compose.production.yml --env-file .env.production.deploy ps
            
            echo ""
            echo "ğŸ‰ Deployment completed successfully!"
            echo "ğŸ“ Access URLs:"
            echo "   ğŸŒ UPS Frontend: http://${{ secrets.EC2_HOST }}:3000"
            echo "   ğŸ›’ Amazon Service: http://${{ secrets.EC2_HOST }}:8080"
            echo "   ğŸ”Œ UPS API: http://${{ secrets.EC2_HOST }}:8081"
            echo "   ğŸ“Š RabbitMQ Management: http://${{ secrets.EC2_HOST }}:15672"
            
            # Show Docker status for verification
            echo ""
            echo "ğŸ³ Docker Container Status:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

  # Notification
  notify-result:
    name: Notify Deployment Result
    runs-on: ubuntu-latest
    needs: [deploy-aws]
    if: always()

    steps:
      - name: Notify Success
        if: needs.deploy-aws.result == 'success'
        run: |
          echo "ğŸ‰ Multi-service deployment completed successfully!"
          echo "ğŸ“ Services are accessible at:"
          echo "   ğŸŒ UPS Frontend: http://${{ secrets.EC2_HOST }}:3000"
          echo "   ğŸ›’ Amazon Service: http://${{ secrets.EC2_HOST }}:8080"  
          echo "   ğŸ”Œ UPS API: http://${{ secrets.EC2_HOST }}:8081"
          echo "   ğŸ“Š RabbitMQ Management: http://${{ secrets.EC2_HOST }}:15672"

      - name: Notify Failure
        if: needs.deploy-aws.result == 'failure' || needs.integration-test.result == 'failure'
        run: |
          echo "âŒ Multi-service deployment failed!"
          echo "ğŸ” Check the job logs for details."
          echo "ğŸ“‹ Common issues:"
          echo "   - Network connectivity to EC2"
          echo "   - Docker image build failures"
          echo "   - Service health check timeouts"
          exit 1