<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NotificationConsumer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Mini UPS Backend</a> &gt; <a href="index.source.html" class="el_package">com.miniups.service.consumer</a> &gt; <span class="el_source">NotificationConsumer.java</span></div><h1>NotificationConsumer.java</h1><pre class="source lang-java linenums">package com.miniups.service.consumer;

import com.miniups.config.RabbitMQConfig;
import com.miniups.model.entity.User;
import com.miniups.model.event.BusinessEvent;
import com.miniups.model.event.NotificationPayload;
import com.miniups.repository.UserRepository;
import com.miniups.service.AsyncAuditService;
import com.rabbitmq.client.Channel;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.time.Instant;
import java.util.Map;
import java.util.Optional;

/**
 * Notification Consumer
 * 
 * Processes notification events asynchronously to send notifications
 * through various channels (email, SMS, push notifications) without
 * blocking the main business flow. This consumer handles the integration
 * with external notification services and manages delivery retries.
 * 
 * Key Features:
 * - Multi-channel notification delivery
 * - Asynchronous notification processing
 * - User preference handling
 * - Delivery retry mechanisms
 * - Template-based notifications
 * - Comprehensive error handling
 * - Idempotent message processing
 * 
 * Supported Notification Types:
 * - Email notifications
 * - SMS notifications  
 * - Push notifications
 * - In-app notifications
 * - Webhook notifications
 * 
 * @author Mini-UPS Development Team
 * @version 1.0
 * @since 2024
 */
@Service
public class NotificationConsumer {
<span class="nc" id="L53">    private static final Logger log = LoggerFactory.getLogger(NotificationConsumer.class);</span>

    private final UserRepository userRepository;
    private final AsyncAuditService asyncAuditService;
    
<span class="nc" id="L58">    public NotificationConsumer(UserRepository userRepository, AsyncAuditService asyncAuditService) {</span>
<span class="nc" id="L59">        this.userRepository = userRepository;</span>
<span class="nc" id="L60">        this.asyncAuditService = asyncAuditService;</span>
<span class="nc" id="L61">    }</span>

    @Value(&quot;${app.notifications.enabled:true}&quot;)
    private boolean notificationsEnabled;

    @Value(&quot;${app.notifications.email.enabled:true}&quot;)
    private boolean emailEnabled;

    @Value(&quot;${app.notifications.sms.enabled:false}&quot;)
    private boolean smsEnabled;

    @Value(&quot;${app.notifications.push.enabled:false}&quot;)
    private boolean pushEnabled;

    /**
     * Process notification events from the queue
     * 
     * This method handles all types of notification events and routes them
     * to the appropriate delivery channels based on the notification type
     * and user preferences.
     * 
     * @param event The business event containing notification data
     * @param message The RabbitMQ message for acknowledgment
     * @param channel The RabbitMQ channel for acknowledgment
     */
    @RabbitListener(queues = RabbitMQConfig.NOTIFICATIONS_QUEUE)
    public void handleNotificationEvent(BusinessEvent&lt;NotificationPayload&gt; event,
                                       Message message,
                                       Channel channel) throws IOException {
        
<span class="nc" id="L91">        long deliveryTag = message.getMessageProperties().getDeliveryTag();</span>
<span class="nc" id="L92">        long startTime = System.currentTimeMillis();</span>
<span class="nc" id="L93">        String correlationId = event.getCorrelationId();</span>
        
        try {
<span class="nc" id="L96">            log.debug(&quot;Processing notification event: {} for user: {} (correlationId: {})&quot;,</span>
<span class="nc" id="L97">                    event.getEventId(), event.getPayload().getRecipientUserId(), correlationId);</span>

            // Check if notifications are globally enabled
<span class="nc bnc" id="L100" title="All 2 branches missed.">            if (!notificationsEnabled) {</span>
<span class="nc" id="L101">                log.debug(&quot;Notifications are disabled globally, skipping event: {}&quot;, event.getEventId());</span>
<span class="nc" id="L102">                channel.basicAck(deliveryTag, false);</span>
<span class="nc" id="L103">                return;</span>
            }

            // Validate the event payload
<span class="nc" id="L107">            NotificationPayload payload = event.getPayload();</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            if (!isValidNotificationPayload(payload)) {</span>
<span class="nc" id="L109">                log.warn(&quot;Invalid notification payload in event: {}&quot;, event.getEventId());</span>
<span class="nc" id="L110">                channel.basicAck(deliveryTag, false);</span>
<span class="nc" id="L111">                return;</span>
            }

            // Check if notification has expired
<span class="nc bnc" id="L115" title="All 2 branches missed.">            if (payload.isExpired()) {</span>
<span class="nc" id="L116">                log.debug(&quot;Notification has expired, skipping event: {}&quot;, event.getEventId());</span>
<span class="nc" id="L117">                channel.basicAck(deliveryTag, false);</span>
<span class="nc" id="L118">                return;</span>
            }

            // Check if we should process this notification immediately or schedule it
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (!payload.isImmediate()) {</span>
<span class="nc" id="L123">                log.debug(&quot;Notification is scheduled for later delivery, should be requeued: {}&quot;, event.getEventId());</span>
                // TODO: Implement scheduled notification handling
<span class="nc" id="L125">                channel.basicNack(deliveryTag, false, true); // requeue for later</span>
<span class="nc" id="L126">                return;</span>
            }

            // Process the notification
<span class="nc" id="L130">            boolean success = processNotification(payload, correlationId, startTime);</span>

<span class="nc bnc" id="L132" title="All 2 branches missed.">            if (success) {</span>
                // Audit successful notification
<span class="nc" id="L134">                Map&lt;String, Object&gt; auditData = Map.of(</span>
<span class="nc" id="L135">                    &quot;notificationId&quot;, payload.getNotificationId(),</span>
<span class="nc" id="L136">                    &quot;recipientUserId&quot;, payload.getRecipientUserId(),</span>
<span class="nc" id="L137">                    &quot;notificationTypes&quot;, payload.getNotificationTypes(),</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                    &quot;subject&quot;, payload.getSubject() != null ? payload.getSubject() : &quot;N/A&quot;,</span>
<span class="nc" id="L139">                    &quot;eventId&quot;, event.getEventId()</span>
                );
<span class="nc" id="L141">                asyncAuditService.auditSuccess(&quot;notification.sent&quot;, payload.getNotificationId(), </span>
                                             &quot;Notification successfully sent&quot;, 
                                             startTime, auditData);

<span class="nc" id="L145">                log.info(&quot;Successfully processed notification event: {} for user: {} (correlationId: {})&quot;,</span>
<span class="nc" id="L146">                        event.getEventId(), payload.getRecipientUserId(), correlationId);</span>

                // Acknowledge successful processing
<span class="nc" id="L149">                channel.basicAck(deliveryTag, false);</span>
<span class="nc" id="L150">            } else {</span>
                // Handle retry logic
<span class="nc" id="L152">                handleNotificationRetry(payload, event, message, channel, correlationId, startTime);</span>
            }

<span class="nc" id="L155">        } catch (Exception e) {</span>
<span class="nc" id="L156">            log.error(&quot;Failed to process notification event: {} (correlationId: {})&quot;, </span>
<span class="nc" id="L157">                     event.getEventId(), correlationId, e);</span>
            
            // Audit the failure
<span class="nc" id="L160">            asyncAuditService.auditFailure(&quot;notification.sent&quot;, </span>
<span class="nc" id="L161">                                         event.getPayload().getNotificationId(), </span>
                                         &quot;Failed to process notification in consumer&quot;, 
                                         startTime, e);
            
            // Handle retry or dead letter
<span class="nc" id="L166">            handleNotificationRetry(event.getPayload(), event, message, channel, correlationId, startTime);</span>
<span class="nc" id="L167">        }</span>
<span class="nc" id="L168">    }</span>

    /**
     * Validate the notification payload
     * Ensures all required fields are present and valid
     * 
     * @param payload The notification payload to validate
     * @return true if the payload is valid for processing
     */
    private boolean isValidNotificationPayload(NotificationPayload payload) {
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (payload == null) {</span>
<span class="nc" id="L179">            return false;</span>
        }

        // Check required fields
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (payload.getRecipientUserId() == null &amp;&amp; </span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            payload.getRecipientEmail() == null &amp;&amp; </span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            payload.getRecipientPhone() == null) {</span>
<span class="nc" id="L186">            log.warn(&quot;Notification payload missing recipient information&quot;);</span>
<span class="nc" id="L187">            return false;</span>
        }

<span class="nc bnc" id="L190" title="All 4 branches missed.">        if (payload.getNotificationTypes() == null || payload.getNotificationTypes().isEmpty()) {</span>
<span class="nc" id="L191">            log.warn(&quot;Notification payload missing notification types&quot;);</span>
<span class="nc" id="L192">            return false;</span>
        }

<span class="nc bnc" id="L195" title="All 4 branches missed.">        if (payload.getMessage() == null || payload.getMessage().trim().isEmpty()) {</span>
<span class="nc" id="L196">            log.warn(&quot;Notification payload missing message content&quot;);</span>
<span class="nc" id="L197">            return false;</span>
        }

<span class="nc" id="L200">        return true;</span>
    }

    /**
     * Process the notification by sending it through appropriate channels
     * 
     * @param payload The notification data
     * @param correlationId The correlation ID for tracking
     * @param startTime The processing start time
     * @return true if notification was sent successfully
     */
    private boolean processNotification(NotificationPayload payload, String correlationId, long startTime) {
<span class="nc" id="L212">        boolean overallSuccess = true;</span>
<span class="nc" id="L213">        int successCount = 0;</span>
<span class="nc" id="L214">        int totalChannels = payload.getNotificationTypes().size();</span>

        // Get user information if user ID is provided
<span class="nc" id="L217">        User user = null;</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (payload.getRecipientUserId() != null) {</span>
<span class="nc" id="L219">            user = getUserById(payload.getRecipientUserId());</span>
        }

        // Process each notification type
<span class="nc bnc" id="L223" title="All 2 branches missed.">        for (NotificationPayload.NotificationType type : payload.getNotificationTypes()) {</span>
            try {
<span class="nc" id="L225">                boolean channelSuccess = false;</span>
                
<span class="nc bnc" id="L227" title="All 6 branches missed.">                switch (type) {</span>
                    case EMAIL:
<span class="nc" id="L229">                        channelSuccess = sendEmailNotification(payload, user, correlationId);</span>
<span class="nc" id="L230">                        break;</span>
                    case SMS:
<span class="nc" id="L232">                        channelSuccess = sendSmsNotification(payload, user, correlationId);</span>
<span class="nc" id="L233">                        break;</span>
                    case PUSH_NOTIFICATION:
<span class="nc" id="L235">                        channelSuccess = sendPushNotification(payload, user, correlationId);</span>
<span class="nc" id="L236">                        break;</span>
                    case IN_APP_NOTIFICATION:
<span class="nc" id="L238">                        channelSuccess = sendInAppNotification(payload, user, correlationId);</span>
<span class="nc" id="L239">                        break;</span>
                    case WEBHOOK:
<span class="nc" id="L241">                        channelSuccess = sendWebhookNotification(payload, correlationId);</span>
<span class="nc" id="L242">                        break;</span>
                    default:
<span class="nc" id="L244">                        log.warn(&quot;Unsupported notification type: {} for event: {}&quot;, type, payload.getNotificationId());</span>
                        break;
                }
                
<span class="nc bnc" id="L248" title="All 2 branches missed.">                if (channelSuccess) {</span>
<span class="nc" id="L249">                    successCount++;</span>
                } else {
<span class="nc" id="L251">                    overallSuccess = false;</span>
                }
                
<span class="nc" id="L254">            } catch (Exception e) {</span>
<span class="nc" id="L255">                log.error(&quot;Failed to send {} notification for user: {} (correlationId: {})&quot;, </span>
<span class="nc" id="L256">                         type, payload.getRecipientUserId(), correlationId, e);</span>
<span class="nc" id="L257">                overallSuccess = false;</span>
<span class="nc" id="L258">            }</span>
<span class="nc" id="L259">        }</span>

<span class="nc" id="L261">        log.info(&quot;Notification processing completed: {}/{} channels successful for user: {} (correlationId: {})&quot;,</span>
<span class="nc" id="L262">                successCount, totalChannels, payload.getRecipientUserId(), correlationId);</span>

        // Consider it successful if at least one channel worked
<span class="nc bnc" id="L265" title="All 2 branches missed.">        return successCount &gt; 0;</span>
    }

    /**
     * Send email notification
     */
    private boolean sendEmailNotification(NotificationPayload payload, User user, String correlationId) {
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (!emailEnabled) {</span>
<span class="nc" id="L273">            log.debug(&quot;Email notifications disabled, skipping for user: {}&quot;, payload.getRecipientUserId());</span>
<span class="nc" id="L274">            return true; // Consider as successful since it's disabled by configuration</span>
        }

        try {
<span class="nc" id="L278">            String emailAddress = payload.getRecipientEmail();</span>
<span class="nc bnc" id="L279" title="All 4 branches missed.">            if (emailAddress == null &amp;&amp; user != null) {</span>
<span class="nc" id="L280">                emailAddress = user.getEmail();</span>
            }

<span class="nc bnc" id="L283" title="All 2 branches missed.">            if (emailAddress == null) {</span>
<span class="nc" id="L284">                log.warn(&quot;No email address available for notification: {}&quot;, payload.getNotificationId());</span>
<span class="nc" id="L285">                return false;</span>
            }

            // TODO: Integrate with actual email service (SendGrid, AWS SES, etc.)
<span class="nc" id="L289">            log.info(&quot;SIMULATED: Sending email to {} with subject: '{}' (correlationId: {})&quot;,</span>
<span class="nc" id="L290">                    emailAddress, payload.getSubject(), correlationId);</span>

            // Simulate email sending delay
<span class="nc" id="L293">            Thread.sleep(100);</span>

<span class="nc" id="L295">            return true;</span>

<span class="nc" id="L297">        } catch (Exception e) {</span>
<span class="nc" id="L298">            log.error(&quot;Failed to send email notification (correlationId: {})&quot;, correlationId, e);</span>
<span class="nc" id="L299">            return false;</span>
        }
    }

    /**
     * Send SMS notification
     */
    private boolean sendSmsNotification(NotificationPayload payload, User user, String correlationId) {
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (!smsEnabled) {</span>
<span class="nc" id="L308">            log.debug(&quot;SMS notifications disabled, skipping for user: {}&quot;, payload.getRecipientUserId());</span>
<span class="nc" id="L309">            return true; // Consider as successful since it's disabled by configuration</span>
        }

        try {
<span class="nc" id="L313">            String phoneNumber = payload.getRecipientPhone();</span>
<span class="nc bnc" id="L314" title="All 4 branches missed.">            if (phoneNumber == null &amp;&amp; user != null) {</span>
                // phoneNumber = user.getPhoneNumber(); // Assuming User entity has phone number
            }

<span class="nc bnc" id="L318" title="All 2 branches missed.">            if (phoneNumber == null) {</span>
<span class="nc" id="L319">                log.warn(&quot;No phone number available for notification: {}&quot;, payload.getNotificationId());</span>
<span class="nc" id="L320">                return false;</span>
            }

            // TODO: Integrate with actual SMS service (Twilio, AWS SNS, etc.)
<span class="nc" id="L324">            log.info(&quot;SIMULATED: Sending SMS to {} with message: '{}' (correlationId: {})&quot;,</span>
<span class="nc" id="L325">                    phoneNumber, truncateForSms(payload.getMessage()), correlationId);</span>

            // Simulate SMS sending delay
<span class="nc" id="L328">            Thread.sleep(50);</span>

<span class="nc" id="L330">            return true;</span>

<span class="nc" id="L332">        } catch (Exception e) {</span>
<span class="nc" id="L333">            log.error(&quot;Failed to send SMS notification (correlationId: {})&quot;, correlationId, e);</span>
<span class="nc" id="L334">            return false;</span>
        }
    }

    /**
     * Send push notification
     */
    private boolean sendPushNotification(NotificationPayload payload, User user, String correlationId) {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (!pushEnabled) {</span>
<span class="nc" id="L343">            log.debug(&quot;Push notifications disabled, skipping for user: {}&quot;, payload.getRecipientUserId());</span>
<span class="nc" id="L344">            return true;</span>
        }

        try {
<span class="nc" id="L348">            String deviceToken = payload.getDeviceToken();</span>
            
<span class="nc bnc" id="L350" title="All 2 branches missed.">            if (deviceToken == null) {</span>
<span class="nc" id="L351">                log.warn(&quot;No device token available for push notification: {}&quot;, payload.getNotificationId());</span>
<span class="nc" id="L352">                return false;</span>
            }

            // TODO: Integrate with actual push notification service (FCM, APNS)
<span class="nc" id="L356">            log.info(&quot;SIMULATED: Sending push notification to device token ending in {} (correlationId: {})&quot;,</span>
<span class="nc" id="L357">                    deviceToken.substring(Math.max(0, deviceToken.length() - 8)), correlationId);</span>

<span class="nc" id="L359">            return true;</span>

<span class="nc" id="L361">        } catch (Exception e) {</span>
<span class="nc" id="L362">            log.error(&quot;Failed to send push notification (correlationId: {})&quot;, correlationId, e);</span>
<span class="nc" id="L363">            return false;</span>
        }
    }

    /**
     * Send in-app notification
     */
    private boolean sendInAppNotification(NotificationPayload payload, User user, String correlationId) {
        try {
            // TODO: Store in-app notification in database for user to see in UI
<span class="nc" id="L373">            log.info(&quot;SIMULATED: Created in-app notification for user: {} (correlationId: {})&quot;,</span>
<span class="nc" id="L374">                    payload.getRecipientUserId(), correlationId);</span>

<span class="nc" id="L376">            return true;</span>

<span class="nc" id="L378">        } catch (Exception e) {</span>
<span class="nc" id="L379">            log.error(&quot;Failed to create in-app notification (correlationId: {})&quot;, correlationId, e);</span>
<span class="nc" id="L380">            return false;</span>
        }
    }

    /**
     * Send webhook notification
     */
    private boolean sendWebhookNotification(NotificationPayload payload, String correlationId) {
        try {
            // TODO: Send HTTP webhook to external system
<span class="nc" id="L390">            log.info(&quot;SIMULATED: Sending webhook notification (correlationId: {})&quot;, correlationId);</span>

<span class="nc" id="L392">            return true;</span>

<span class="nc" id="L394">        } catch (Exception e) {</span>
<span class="nc" id="L395">            log.error(&quot;Failed to send webhook notification (correlationId: {})&quot;, correlationId, e);</span>
<span class="nc" id="L396">            return false;</span>
        }
    }

    /**
     * Handle notification retry logic
     */
    private void handleNotificationRetry(NotificationPayload payload, BusinessEvent&lt;?&gt; event, 
                                       Message message, Channel channel, 
                                       String correlationId, long startTime) throws IOException {
        
<span class="nc" id="L407">        long deliveryTag = message.getMessageProperties().getDeliveryTag();</span>
        
        // Increment attempt counter
<span class="nc" id="L410">        payload.incrementAttempt();</span>
        
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (payload.isMaxRetriesExceeded()) {</span>
<span class="nc" id="L413">            log.warn(&quot;Max retry attempts exceeded for notification: {} (correlationId: {})&quot;, </span>
<span class="nc" id="L414">                    payload.getNotificationId(), correlationId);</span>
            
            // Audit the failure
<span class="nc" id="L417">            asyncAuditService.auditFailure(&quot;notification.max_retries&quot;, payload.getNotificationId(), </span>
                                         &quot;Notification failed after max retry attempts&quot;, 
                                         startTime, new RuntimeException(&quot;Max retries exceeded&quot;));
            
            // Send to dead letter queue
<span class="nc" id="L422">            channel.basicNack(deliveryTag, false, false);</span>
        } else {
<span class="nc" id="L424">            log.info(&quot;Requeuing notification for retry: {} (attempt: {}/{}) (correlationId: {})&quot;, </span>
<span class="nc" id="L425">                    payload.getNotificationId(), payload.getCurrentAttempt(), </span>
<span class="nc" id="L426">                    payload.getMaxRetryAttempts(), correlationId);</span>
            
            // Requeue for retry
<span class="nc" id="L429">            channel.basicNack(deliveryTag, false, true);</span>
        }
<span class="nc" id="L431">    }</span>

    /**
     * Get user by ID
     */
    private User getUserById(Long userId) {
        try {
<span class="nc" id="L438">            Optional&lt;User&gt; userOpt = userRepository.findById(userId);</span>
<span class="nc" id="L439">            return userOpt.orElse(null);</span>
<span class="nc" id="L440">        } catch (Exception e) {</span>
<span class="nc" id="L441">            log.error(&quot;Failed to get user by ID: {}&quot;, userId, e);</span>
<span class="nc" id="L442">            return null;</span>
        }
    }

    /**
     * Truncate message for SMS (160 character limit)
     */
    private String truncateForSms(String message) {
<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (message == null) {</span>
<span class="nc" id="L451">            return &quot;&quot;;</span>
        }
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (message.length() &lt;= 160) {</span>
<span class="nc" id="L454">            return message;</span>
        }
<span class="nc" id="L456">        return message.substring(0, 157) + &quot;...&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>